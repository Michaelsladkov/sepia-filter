# assignment-sepia

При оптиммальном использовании инструкций sse мы можем эффективно обработать 4 пикселя за один вызов. 
Из программы на C мы хотим совершать вызов, передавать функции указатель на 4 пикселя (12 целых 8-битных чисел).
Ассемблерная функция должна сама преобразовать целые числа в числа с плавающей точкой, разложить их в памяти, закинуть в xmm регистры, провести умножение и сложение. Тогда перед модклем на ассемблере встают следующие задачи: 
1. Преобразование целых чисел в числа с плавающей точкой
1. Укладка чисел с плавающей точкой в память в том порядке, в котором они должны быть загружены в xmm регистры
1. Работа с числами в xmm регистах
1. Преобразование положительных чисел с плавающей точкой в целые 8-битные числа с насыщением

Ассемблерная функция должна сложить изменённые пиксели на место исходных.

## Исследование времени выполнения
Для исследования было взято изображение размером 6000x3376, в формате BMP оно занимает 57Мб. Было проведено 10 измерений времени обработки

|# измерения|t_sse, мкс|t_no_sse, мкс|
|-----------|----------|-------------|
|1|60258|193074
|2|75944|210020
|3|79054|209740
|4|110728|205219
|5|77469|204036
|6|101807|215950
|7|75565|204097
|8|76523|205746
|9|92022|198482
|10|76851|209627

Вычислим средние значения для каждого времени. 

`<t_sse> = 82622,1 мкс`

`<t_no_sse> = 205599,1 мкс`

Далее найдём среднеквадратичные отклонения

`S_sse = 4655,58585 мкс`

`S_no_sse = 2034,298686 мкс`

Теперь мы можем найти доверительные интервалы

`d_sse = 10521,624 мкс`

`d_sse = 4597,515 мкс`

Разброс значение времени исполнения процедуры с использованием SSE оказался больше, однако в среднем она исполнялась более, чем в два раза быстрее, чем процедура на СИ выполняющая те же действия.
